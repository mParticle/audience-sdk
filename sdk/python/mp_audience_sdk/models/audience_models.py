# generated by datamodel-codegen:
#   filename:  audience-definition-schema.json
#   timestamp: 2025-06-30T23:29:20+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, List

from pydantic import BaseModel, ConfigDict, Field, RootModel


class Model(RootModel[Any]):
    root: Any


class AbsoluteDate(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    absolute: str


class AggregationNumberOperator(Enum):
    min = "min"
    max = "max"
    sum = "sum"
    avg = "avg"
    list = "list"
    count = "count"


class AudienceOperator(Enum):
    in_ = "in"
    not_in = "not_in"


class AudienceReference(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    audience: str


class BinaryNumberOperator(Enum):
    plus = "plus"
    minus = "minus"
    multiply = "multiply"
    divide = "divide"
    mod = "mod"


class DateUnit(Enum):
    second = "second"
    minute = "minute"
    hour = "hour"
    day = "day"
    week = "week"
    month = "month"
    quarter = "quarter"
    year = "year"


class DistanceUnit(Enum):
    meters = "meters"
    miles = "miles"
    kilometers = "kilometers"


class ListBoolOperator(Enum):
    contains = "contains"
    between = "between"
    match_any = "match_any"
    match_all = "match_all"
    in_ = "in"
    not_in = "not_in"


class Distance(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    unit: DistanceUnit
    value: float


class Location(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    distance: Distance | None = None
    latitude: float
    longitude: float


class LocationBoolOperator(Enum):
    within = "within"
    equals = "equals"


class LogicalBoolOperator(Enum):
    and_ = "and"
    or_ = "or"


class ModelPath(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model: str
    path: str


class ModelReference(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model: str


class NumberBoolOperator(Enum):
    equals = "equals"
    not_equals = "not_equals"
    less_than = "less_than"
    less_than_equal = "less_than_equal"
    greater_than = "greater_than"
    greater_than_equal = "greater_than_equal"


class Boundary(Enum):
    start = "start"
    end = "end"


class Relative(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    boundary: Boundary | None = None
    offset: float
    unit: DateUnit


class RelativeDate(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    relative: Relative


class StringBoolOperator(Enum):
    equals = "equals"
    not_equals = "not_equals"
    matches = "matches"
    contains = "contains"
    not_contains = "not_contains"
    starts_with = "starts_with"
    not_starts_with = "not_starts_with"
    ends_with = "ends_with"
    not_ends_with = "not_ends_with"
    in_ = "in"
    not_in = "not_in"


class StringExpression(RootModel[str | ModelPath]):
    root: str | ModelPath = Field(..., title="StringExpression")


class UnaryBoolOperator(Enum):
    null = "null"
    not_null = "not_null"
    exists = "exists"
    not_exists = "not_exists"


class Version(RootModel[str]):
    root: str


class NamedArgs(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    obj: Any = Field(..., description="Any object to validate")


class IsValidAudienceObject(BaseModel):
    named_args: NamedArgs | None = Field(None, alias="namedArgs")


class AudienceBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: ModelReference
    operator: AudienceOperator
    right: AudienceReference


class DateLiteral(RootModel[AbsoluteDate | RelativeDate]):
    root: AbsoluteDate | RelativeDate = Field(..., title="DateLiteral")


class DateLiteralExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    date: AbsoluteDate | RelativeDate


class Literal(RootModel[bool | float | str | DateLiteral | ModelPath | Location]):
    root: bool | float | str | DateLiteral | ModelPath | Location = Field(
        ...,
        description='Represents a value that can be used in expressions, including primitive values, paths, and arithmetic operations.\nExamples:\n1. Primitive values:\ntrue\n42\n"hello"\n\n2. Path reference:\n{ path: "user.age" }\n\n3. Arithmetic operation:\n{\noperator: "plus",\nleft: { path: "price" },\nright: { path: "tax" }\n}\n\n4. Nested arithmetic operation:\n{\noperator: "multiply",\nleft: { operator: "plus", left: { path: "base_price" }, right: { path: "shipping" } },\nright: 1.1\n}\n\n5. Date operand:\n{ date: { absolute: "2023-01-01T00:00:00Z" } }',
        title="Literal",
    )


class LocationExpression(RootModel[Location | ModelPath]):
    root: Location | ModelPath = Field(
        ...,
        description='Represents an expression that evaluates to a location or location-based condition.\nExamples:\n1. Simple location:\n{ latitude: 40.7128, longitude: -74.0060, distance: { value: 5, unit: "miles" } }\n\n2. Location with operator:\n{ operator: "within", operand: { latitude: 40.7128, longitude: -74.0060, distance: { value: 5, unit: "miles" } } }\n\n3. Logical combination of locations:\n{\noperator: "or",\nexpressions: [\n{ latitude: 40.7128, longitude: -74.0060, distance: { value: 5, unit: "miles" } },\n{ operator: "within", operand: { latitude: 34.0522, longitude: -118.2437, distance: { value: 10, unit: "miles" } } }\n]\n}',
        title="LocationExpression",
    )


class StringBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: StringExpression
    operator: StringBoolOperator
    right: StringExpression


class DateExpression(RootModel[DateLiteralExpression | ModelPath]):
    root: DateLiteralExpression | ModelPath = Field(
        ...,
        description='Represents an expression that evaluates to a date or date-based condition.\nExamples:\n1. Absolute date:\n{ absolute: "2023-01-01T00:00:00Z" }\n\n2. Relative date:\n{ relative: { offset: -30, unit: "day" } }\n\n3. Date with binary operator:\n{ operator: "greater_than", operand: { absolute: "2023-01-01T00:00:00Z" } }\n\n4. Logical combination of dates:\n{\noperator: "and",\nexpressions: [\n{ absolute: "2023-01-01T00:00:00Z" },\n{ operator: "less_than", operand: { relative: { offset: 0, unit: "month", boundary: "end" } } }\n]\n}',
        title="BooleanExpression",
    )


class LocationBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: LocationExpression
    operator: LocationBoolOperator
    right: LocationExpression


class DateBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: DateExpression
    operator: NumberBoolOperator
    right: DateExpression


class AggregateNumberExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    condition: BoolExpression | None = None
    group_by_model: str
    operand: NumberExpression
    operator: AggregationNumberOperator


class AudienceDefinition(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    audience: BoolExpression = Field(..., title="Audience")
    schema_version: Version


class BinaryNumberExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: NumberExpression
    operator: BinaryNumberOperator
    right: NumberExpression


class BoolExpression(
    RootModel[
        bool
        | ModelPath
        | UnaryBoolExpression
        | NumberBoolExpression
        | StringBoolExpression
        | DateBoolExpression
        | LogicalBoolExpression
        | LogicalManyBoolExpression
        | LocationBoolExpression
    ]
):
    root: (
        bool
        | ModelPath
        | UnaryBoolExpression
        | NumberBoolExpression
        | StringBoolExpression
        | DateBoolExpression
        | LogicalBoolExpression
        | LogicalManyBoolExpression
        | LocationBoolExpression
    ) = Field(..., title="BoolExpression")


class Expression(
    RootModel[BoolExpression | DateExpression | NumberExpression | LocationExpression]
):
    root: BoolExpression | DateExpression | NumberExpression | LocationExpression = (
        Field(
            ...,
            description='Represents a complex expression that can evaluate to true, false, or noop.\nExamples:\n1. Join expression (combining expressions from different models):\n{\n"model": "user",\n"expression": {\n"operator": "equals",\n"left": { "path": "age" },\n"right": 18\n}\n}\n\n2. Logical expression (AND):\n{\n"operator": "and",\n"expressions": [\n{ "operator": "equals", "left": { "path": "country" }, "right": "US" },\n{ "operator": "greater_than", "left": { "path": "age" }, "right": 18 }\n]\n}\n\n3. Location expression:\n{\n"operator": "within",\n"left": { "location": { "latitude": 37.7749, "longitude": -122.4194, "distance": { "value": 10, "unit": "miles" } } },\n"right": { "model": "user", "path": "location" }\n}',
            title="Expression",
        )
    )


class LogicalBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: BoolExpression
    operator: LogicalBoolOperator
    right: BoolExpression


class LogicalManyBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expressions: List[BoolExpression]
    operator: LogicalBoolOperator


class NumberBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: NumberExpression
    operator: NumberBoolOperator
    right: NumberExpression


class NumberExpression(
    RootModel[float | ModelPath | BinaryNumberExpression | AggregateNumberExpression]
):
    root: float | ModelPath | BinaryNumberExpression | AggregateNumberExpression = (
        Field(
            ...,
            description='Represents a count expression, which can be a number, a binary operation, or a logical group.\nExamples:\n1. Simple count:\n5\n\n2. Binary count expression:\n{ operator: "greater_than", operand: { path: "event.count" } }\n\n3. Logical group of count expressions:\n{\noperator: "and",\nexpressions: [\n1,\n{ operator: "greater_than", operand: { path: "event.count" } }\n]\n}',
            title="NumberExpression",
        )
    )


class UnaryBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operand: Expression
    operator: UnaryBoolOperator


AggregateNumberExpression.model_rebuild()
AudienceDefinition.model_rebuild()
BinaryNumberExpression.model_rebuild()
BoolExpression.model_rebuild()
Expression.model_rebuild()
NumberBoolExpression.model_rebuild()
