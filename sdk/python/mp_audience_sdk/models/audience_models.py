# generated by datamodel-codegen:
#   filename:  audience-definition-schema.json
#   timestamp: 2025-07-01T00:52:21+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, List

from pydantic import BaseModel, ConfigDict, Field, RootModel


class Model(RootModel["Any"]):
    root: Any


class AbsoluteDate(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    absolute: str


class AggregationNumberOperator(Enum):
    min = "min"
    max = "max"
    sum = "sum"
    avg = "avg"
    list = "list"
    count = "count"


class AudienceOperator(Enum):
    in_ = "in"
    not_in = "not_in"


class AudienceReference(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    audience: str


class BinaryNumberOperator(Enum):
    plus = "plus"
    minus = "minus"
    multiply = "multiply"
    divide = "divide"
    mod = "mod"


class DateUnit(Enum):
    second = "second"
    minute = "minute"
    hour = "hour"
    day = "day"
    week = "week"
    month = "month"
    quarter = "quarter"
    year = "year"


class DistanceUnit(Enum):
    meters = "meters"
    miles = "miles"
    kilometers = "kilometers"


class ListBoolOperator(Enum):
    contains = "contains"
    between = "between"
    match_any = "match_any"
    match_all = "match_all"
    in_ = "in"
    not_in = "not_in"


class Distance(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    unit: DistanceUnit
    value: float


class Location(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    distance: Distance | None = None
    latitude: float
    longitude: float


class LocationBoolOperator(Enum):
    within = "within"
    equals = "equals"


class LogicalBoolOperator(Enum):
    and_ = "and"
    or_ = "or"


class ModelPath(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model: str
    path: str


class ModelReference(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model: str


class NumberBoolOperator(Enum):
    equals = "equals"
    not_equals = "not_equals"
    less_than = "less_than"
    less_than_equal = "less_than_equal"
    greater_than = "greater_than"
    greater_than_equal = "greater_than_equal"


class Boundary(Enum):
    start = "start"
    end = "end"


class Relative(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    boundary: Boundary | None = None
    offset: float
    unit: DateUnit


class RelativeDate(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    relative: Relative


class StringBoolOperator(Enum):
    equals = "equals"
    not_equals = "not_equals"
    matches = "matches"
    contains = "contains"
    not_contains = "not_contains"
    starts_with = "starts_with"
    not_starts_with = "not_starts_with"
    ends_with = "ends_with"
    not_ends_with = "not_ends_with"
    in_ = "in"
    not_in = "not_in"


class UnaryBoolOperator(Enum):
    null = "null"
    not_null = "not_null"
    exists = "exists"
    not_exists = "not_exists"


class ValueBoolExpression(RootModel["bool | ModelPath"]):
    root: bool | ModelPath = Field(..., title="ValueBoolExpression")


class ValueLocationExpression(RootModel["Location | ModelPath"]):
    root: Location | ModelPath = Field(..., title="ValueLocationExpression")


class ValueNumberExpression(RootModel["float | ModelPath"]):
    root: float | ModelPath = Field(..., title="ValueNumberExpression")


class ValueStringExpression(RootModel["str | ModelPath"]):
    root: str | ModelPath = Field(..., title="ValueStringExpression")


class Version(RootModel["str"]):
    root: str


class NamedArgs(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    obj: Any = Field(..., description="Any object to validate")


class IsValidAudienceObject(BaseModel):
    named_args: NamedArgs | None = Field(None, alias="namedArgs")


class AudienceBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: ModelReference
    operator: AudienceOperator
    right: AudienceReference


class DateLiteral(RootModel["AbsoluteDate | RelativeDate"]):
    root: AbsoluteDate | RelativeDate = Field(..., title="DateLiteral")


class Literal(
    RootModel[
        "bool | float | str | DateLiteral | ModelPath | Location | ModelReference | AudienceReference"
    ]
):
    root: (
        bool
        | float
        | str
        | DateLiteral
        | ModelPath
        | Location
        | ModelReference
        | AudienceReference
    ) = Field(
        ...,
        description='Represents a value that can be used in expressions, including primitive values, paths, and arithmetic operations.\nExamples:\n1. Primitive values:\ntrue\n42\n"hello"\n\n2. Path reference:\n{ path: "user.age" }\n\n3. Arithmetic operation:\n{\noperator: "plus",\nleft: { path: "price" },\nright: { path: "tax" }\n}\n\n4. Nested arithmetic operation:\n{\noperator: "multiply",\nleft: { operator: "plus", left: { path: "base_price" }, right: { path: "shipping" } },\nright: 1.1\n}\n\n5. Date operand:\n{ date: { absolute: "2023-01-01T00:00:00Z" } }',
        title="Literal",
    )


class LocationExpression(RootModel["ValueLocationExpression"]):
    root: ValueLocationExpression = Field(
        ...,
        description="Represents an expression that evaluates to a location or location-based condition.",
        title="LocationExpression",
    )


class StringExpression(RootModel["ValueStringExpression"]):
    root: ValueStringExpression = Field(..., title="StringExpression")


class ValueDateExpression1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    date: DateLiteral


class ValueDateExpression(RootModel["ValueDateExpression1 | ModelPath"]):
    root: ValueDateExpression1 | ModelPath = Field(..., title="ValueDateExpression")


class ValueExpression(
    RootModel[
        "ValueBoolExpression | ValueDateExpression | ValueLocationExpression | ValueNumberExpression | ValueStringExpression"
    ]
):
    root: (
        ValueBoolExpression
        | ValueDateExpression
        | ValueLocationExpression
        | ValueNumberExpression
        | ValueStringExpression
    ) = Field(..., title="ValueExpression")


class DateExpression(RootModel["ValueDateExpression"]):
    root: ValueDateExpression = Field(
        ...,
        description="Represents an expression that evaluates to a date",
        title="DateExpression",
    )


class LocationBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: LocationExpression
    operator: LocationBoolOperator
    right: LocationExpression


class StringBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: StringExpression
    operator: StringBoolOperator
    right: StringExpression


class DateBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: DateExpression
    operator: NumberBoolOperator
    right: DateExpression


class AggregateExpression(RootModel["AggregateNumberExpression"]):
    root: AggregateNumberExpression = Field(..., title="AggregateExpression")


class AggregateNumberExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    condition: BoolExpression | None = None
    group_by_model: str
    operand: NumberExpression
    operator: AggregationNumberOperator


class AudienceDefinition(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    audience: BoolExpression = Field(..., title="Audience")
    schema_version: Version


class BinaryBoolExpression(
    RootModel[
        "AudienceBoolExpression | LocationBoolExpression | DateBoolExpression | StringBoolExpression | NumberBoolExpression"
    ]
):
    root: (
        AudienceBoolExpression
        | LocationBoolExpression
        | DateBoolExpression
        | StringBoolExpression
        | NumberBoolExpression
    ) = Field(..., title="BoolBinaryExpression")


class BinaryExpression(RootModel["BinaryBoolExpression | BinaryNumberExpression"]):
    root: BinaryBoolExpression | BinaryNumberExpression = Field(
        ..., title="BinaryExpression"
    )


class BinaryNumberExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: NumberExpression
    operator: BinaryNumberOperator
    right: NumberExpression


class BoolExpression(
    RootModel[
        "ValueBoolExpression | UnaryBoolExpression | BinaryBoolExpression | ManyBoolExpression"
    ]
):
    root: (
        ValueBoolExpression
        | UnaryBoolExpression
        | BinaryBoolExpression
        | ManyBoolExpression
    ) = Field(..., title="BoolExpression")


class Expression(
    RootModel[
        "ValueExpression | UnaryExpression | IBinaryExpression | ManyExpression | BoolExpression | NumberExpression | StringExpression | LocationExpression | DateExpression | Literal"
    ]
):
    root: (
        ValueExpression
        | UnaryExpression
        | IBinaryExpression
        | ManyExpression
        | BoolExpression
        | NumberExpression
        | StringExpression
        | LocationExpression
        | DateExpression
        | Literal
    ) = Field(
        ...,
        description="Represents an expression that accepts a variety of arguments and evaluates to a value.",
        title="Expression",
    )


class IAggregateExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    condition: Expression | None = None
    group_by_model: str
    operand: Expression


class IBinaryExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: Expression
    right: Expression


class IManyExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expressions: List[Expression]


class IUnaryExpressionExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operand: Expression


class LogicalBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: BoolExpression
    operator: LogicalBoolOperator
    right: BoolExpression


class LogicalManyBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expressions: List[BoolExpression]
    operator: LogicalBoolOperator


class ManyBoolExpression(RootModel["LogicalManyBoolExpression"]):
    root: LogicalManyBoolExpression = Field(..., title="ManyBoolExpression")


class ManyExpression(RootModel["ManyBoolExpression"]):
    root: ManyBoolExpression = Field(..., title="ManyExpression")


class NumberBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: NumberExpression
    operator: NumberBoolOperator
    right: NumberExpression


class NumberExpression(
    RootModel[
        "ValueNumberExpression | BinaryNumberExpression | AggregateNumberExpression"
    ]
):
    root: ValueNumberExpression | BinaryNumberExpression | AggregateNumberExpression = (
        Field(
            ...,
            description="Represents an expression that evaluates to a number.",
            title="NumberExpression",
        )
    )


class UnaryBoolExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operand: Expression
    operator: UnaryBoolOperator


class UnaryExpression(RootModel["UnaryBoolExpression"]):
    root: UnaryBoolExpression = Field(..., title="UnaryExpression")


AggregateExpression.model_rebuild()
AggregateNumberExpression.model_rebuild()
AudienceDefinition.model_rebuild()
BinaryBoolExpression.model_rebuild()
BinaryExpression.model_rebuild()
BinaryNumberExpression.model_rebuild()
BoolExpression.model_rebuild()
Expression.model_rebuild()
NumberBoolExpression.model_rebuild()
