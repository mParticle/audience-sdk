# generated by datamodel-codegen:
#   filename:  audience-definition-schema.json
#   timestamp: 2025-06-04T15:51:30+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel


class Model(RootModel[Any]):
    root: Any


class AbsoluteDate(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    absolute: str


class AggregationOperator(Enum):
    min = "min"
    max = "max"
    sum = "sum"
    avg = "avg"
    list = "list"
    count = "count"


class ArithmeticOperator(Enum):
    plus = "plus"
    minus = "minus"
    multiply = "multiply"
    divide = "divide"
    mod = "mod"


class BinaryOperator(Enum):
    equals = "equals"
    not_equals = "not_equals"
    less_than = "less_than"
    less_than_equal = "less_than_equal"
    greater_than = "greater_than"
    greater_than_equal = "greater_than_equal"
    matches = "matches"
    contains = "contains"
    not_contains = "not_contains"
    starts_with = "starts_with"
    not_starts_with = "not_starts_with"
    ends_with = "ends_with"
    not_ends_with = "not_ends_with"


class AbsoluteDateExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    date: AbsoluteDate


class DateUnit(Enum):
    second = "second"
    minute = "minute"
    hour = "hour"
    day = "day"
    week = "week"
    month = "month"
    quarter = "quarter"
    year = "year"


class DistanceUnit(Enum):
    meters = "meters"
    miles = "miles"
    kilometers = "kilometers"


class ListOperator(Enum):
    contains = "contains"
    between = "between"
    match_any = "match_any"
    match_all = "match_all"
    in_ = "in"


class Distance(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    unit: DistanceUnit
    value: float


class Location(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    distance: Optional[Distance] = None
    latitude: float
    longitude: float


class LocationOperator(Enum):
    within = "within"
    equals = "equals"


class LogicalOperator(Enum):
    and_ = "and"
    or_ = "or"


class ModelPath(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model: str
    path: str


class Boundary(Enum):
    start = "start"
    end = "end"


class Relative(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    boundary: Optional[Boundary] = None
    offset: float
    unit: DateUnit


class RelativeDate(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    relative: Relative


class UnaryOperator(Enum):
    null = "null"
    not_null = "not_null"
    exists = "exists"
    not_exists = "not_exists"


class Version(RootModel[str]):
    root: str


class RelativeDateExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    date: RelativeDate


class DateExpression(RootModel[Union[AbsoluteDateExpression, RelativeDateExpression]]):
    root: Union[AbsoluteDateExpression, RelativeDateExpression] = Field(
        ...,
        description='Represents a date value that can be either absolute or relative. Examples: 1. Absolute date:    { date: { absolute: "2023-01-01T00:00:00Z" } }\n\n2. Relative date (30 days ago):    { date: { relative: { offset: -30, unit: "day" } } }\n\n3. Relative date (start of current month):    { date: { relative: { offset: 0, unit: "month", boundary: "start" } } }',
    )


class AudienceDefinition(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    audience: Condition = Field(..., title="Audience")
    schema_version: Version


class JoinCondition(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expression: Expression
    model: str


class UnaryCondition(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operand: Union[Expression, List[Expression]]
    operator: UnaryOperator


class BinaryCondition(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: Union[Expression, List[Expression]]
    operator: BinaryOperator
    right: Union[Expression, List[Expression]]


class LogicalCondition(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    conditions: List[Condition]
    operator: LogicalOperator


class Condition(
    RootModel[Union[JoinCondition, UnaryCondition, BinaryCondition, LogicalCondition]]
):
    root: Union[JoinCondition, UnaryCondition, BinaryCondition, LogicalCondition] = (
        Field(
            ...,
            description='Represents a complex expression that can evaluate to true, false, or noop. Examples: 1. Join expression (combining expressions from different models):    {      "model": "user",      "expression": {        "operator": "equals",        "left": { "path": "age" },        "right": 18      }    }\n\n2. Logical expression (AND):    {      "operator": "and",      "expressions": [        { "operator": "equals", "left": { "path": "country" }, "right": "US" },        { "operator": "greater_than", "left": { "path": "age" }, "right": 18 }      ]    }\n\n3. Location expression:    {      "operator": "within",      "left": { "location": { "latitude": 37.7749, "longitude": -122.4194, "distance": { "value": 10, "unit": "miles" } } },      "right": { "model": "user", "path": "location" }    }',
        )
    )


class ModelAggregationExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    condition: Condition
    expression: Expression
    group_by_model: str
    operator: AggregationOperator


class Expression(
    RootModel[
        Union[bool, float, str, DateExpression, ModelPath, ModelAggregationExpression]
    ]
):
    root: Union[
        bool, float, str, DateExpression, ModelPath, ModelAggregationExpression
    ] = Field(
        ...,
        description='Represents a value that can be used in expressions, including primitive values, paths, and arithmetic operations. Examples: 1. Primitive values:    true    42    "hello"\n\n2. Path reference:    { path: "user.age" }\n\n3. Arithmetic operation:    {      operator: "plus",      left: { path: "price" },      right: { path: "tax" }    }\n\n4. Nested arithmetic operation:    {      operator: "multiply",      left: { operator: "plus", left: { path: "base_price" }, right: { path: "shipping" } },      right: 1.1    }\n\n5. Date operand:    { date: { absolute: "2023-01-01T00:00:00Z" } }',
    )


AudienceDefinition.model_rebuild()
JoinCondition.model_rebuild()
UnaryCondition.model_rebuild()
BinaryCondition.model_rebuild()
LogicalCondition.model_rebuild()
ModelAggregationExpression.model_rebuild()
