# generated by datamodel-codegen:
#   filename:  audience-definition-schema.json
#   timestamp: 2025-06-19T19:24:53+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel


class Model(RootModel[Any]):
    root: Any


class AbsoluteDate(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    absolute: str


class AggregationOperator(Enum):
    min = "min"
    max = "max"
    sum = "sum"
    avg = "avg"
    list = "list"
    count = "count"


class ArithmeticOperator(Enum):
    plus = "plus"
    minus = "minus"
    multiply = "multiply"
    divide = "divide"
    mod = "mod"


class AudienceOperand(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    audience: float


class AudienceOperator(Enum):
    in_ = "in"
    not_in = "not_in"


class BinaryOperator(Enum):
    equals = "equals"
    not_equals = "not_equals"
    less_than = "less_than"
    less_than_equal = "less_than_equal"
    greater_than = "greater_than"
    greater_than_equal = "greater_than_equal"
    matches = "matches"
    contains = "contains"
    not_contains = "not_contains"
    starts_with = "starts_with"
    not_starts_with = "not_starts_with"
    ends_with = "ends_with"
    not_ends_with = "not_ends_with"


class AbsoluteDateOperand(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    date: AbsoluteDate


class DateUnit(Enum):
    second = "second"
    minute = "minute"
    hour = "hour"
    day = "day"
    week = "week"
    month = "month"
    quarter = "quarter"
    year = "year"


class DistanceUnit(Enum):
    meters = "meters"
    miles = "miles"
    kilometers = "kilometers"


class ListOperator(Enum):
    contains = "contains"
    between = "between"
    match_any = "match_any"
    match_all = "match_all"
    in_ = "in"
    not_in = "not_in"


class Distance(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    unit: DistanceUnit
    value: float


class Location(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    distance: Optional[Distance] = None
    latitude: float
    longitude: float


class LocationOperand(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    location: Location


class LocationOperator(Enum):
    within = "within"
    equals = "equals"


class LogicalOperator(Enum):
    and_ = "and"
    or_ = "or"


class ModelOperand(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model: str


class ModelPath(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model: str
    path: str


class Boundary(Enum):
    start = "start"
    end = "end"


class Relative(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    boundary: Optional[Boundary] = None
    offset: float
    unit: DateUnit


class RelativeDate(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    relative: Relative


class UnaryOperator(Enum):
    null = "null"
    not_null = "not_null"
    exists = "exists"
    not_exists = "not_exists"


class Version(RootModel[str]):
    root: str


class NamedArgs(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    obj: Any = Field(..., description="Any object to validate")


class IsValidAudienceObject(BaseModel):
    named_args: Optional[NamedArgs] = Field(None, alias="namedArgs")


class DateExpression1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operand: Union[AbsoluteDate, RelativeDate]
    operator: BinaryOperator


class RelativeDateOperand(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    date: RelativeDate


class DateOperand(RootModel[Union[AbsoluteDateOperand, RelativeDateOperand]]):
    root: Union[AbsoluteDateOperand, RelativeDateOperand] = Field(
        ...,
        description='Represents a date value that can be either absolute or relative. Examples: 1. Absolute date:    { date: { absolute: "2023-01-01T00:00:00Z" } }\n\n2. Relative date (30 days ago):    { date: { relative: { offset: -30, unit: "day" } } }\n\n3. Relative date (start of current month):    { date: { relative: { offset: 0, unit: "month", boundary: "start" } } }',
    )


class LocationExpression1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operand: Location
    operator: LocationOperator


class AudienceDefinition(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    audience: Expression = Field(..., title="Audience")
    schema_version: Version


class CountExpression1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operand: Operand
    operator: BinaryOperator


class CountExpression2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expressions: List[CountExpression]
    operator: LogicalOperator


class CountExpression(RootModel[Union[float, CountExpression1, CountExpression2]]):
    root: Union[float, CountExpression1, CountExpression2] = Field(
        ...,
        description='Represents a count expression, which can be a number, a binary operation, or a logical group. Examples: 1. Simple count:    5\n\n2. Binary count expression:    { operator: "greater_than", operand: { path: "event.count" } }\n\n3. Logical group of count expressions:    {      operator: "and",      expressions: [        1,        { operator: "greater_than", operand: { path: "event.count" } }      ]    }',
    )


class DateExpression2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expressions: List[DateExpression]
    operator: LogicalOperator


class DateExpression(
    RootModel[Union[AbsoluteDate, RelativeDate, DateExpression1, DateExpression2]]
):
    root: Union[AbsoluteDate, RelativeDate, DateExpression1, DateExpression2] = Field(
        ...,
        description='Represents an expression that evaluates to a date or date-based condition. Examples: 1. Absolute date:    { absolute: "2023-01-01T00:00:00Z" }\n\n2. Relative date:    { relative: { offset: -30, unit: "day" } }\n\n3. Date with binary operator:    { operator: "greater_than", operand: { absolute: "2023-01-01T00:00:00Z" } }\n\n4. Logical combination of dates:    {      operator: "and",      expressions: [        { absolute: "2023-01-01T00:00:00Z" },        { operator: "less_than", operand: { relative: { offset: 0, unit: "month", boundary: "end" } } }      ]    }',
    )


class UnaryExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operand: Operand
    operator: UnaryOperator


class BinaryExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: Operand
    operator: BinaryOperator
    right: Operand


class LogicalExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expressions: List[Expression]
    operator: LogicalOperator


class Expression(
    RootModel[Union[UnaryExpression, BinaryExpression, LogicalExpression]]
):
    root: Union[UnaryExpression, BinaryExpression, LogicalExpression] = Field(
        ...,
        description='Represents a complex expression that can evaluate to true, false, or noop. Examples: 1. Join expression (combining expressions from different models):    {      "model": "user",      "expression": {        "operator": "equals",        "left": { "path": "age" },        "right": 18      }    }\n\n2. Logical expression (AND):    {      "operator": "and",      "expressions": [        { "operator": "equals", "left": { "path": "country" }, "right": "US" },        { "operator": "greater_than", "left": { "path": "age" }, "right": 18 }      ]    }\n\n3. Location expression:    {      "operator": "within",      "left": { "location": { "latitude": 37.7749, "longitude": -122.4194, "distance": { "value": 10, "unit": "miles" } } },      "right": { "model": "user", "path": "location" }    }',
    )


class LocationExpression2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expressions: List[LocationExpression]
    operator: LogicalOperator


class LocationExpression(
    RootModel[Union[Location, LocationExpression1, LocationExpression2]]
):
    root: Union[Location, LocationExpression1, LocationExpression2] = Field(
        ...,
        description='Represents an expression that evaluates to a location or location-based condition. Examples: 1. Simple location:    { latitude: 40.7128, longitude: -74.0060, distance: { value: 5, unit: "miles" } }\n\n2. Location with operator:    { operator: "within", operand: { latitude: 40.7128, longitude: -74.0060, distance: { value: 5, unit: "miles" } } }\n\n3. Logical combination of locations:    {      operator: "or",      expressions: [        { latitude: 40.7128, longitude: -74.0060, distance: { value: 5, unit: "miles" } },        { operator: "within", operand: { latitude: 34.0522, longitude: -118.2437, distance: { value: 10, unit: "miles" } } }      ]    }',
    )


class ModelAggregationOperand(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    condition: Optional[Expression] = None
    group_by_model: str
    operand: Operand
    operator: AggregationOperator


class Operand(
    RootModel[
        Union[
            bool,
            float,
            str,
            DateOperand,
            ModelPath,
            ModelOperand,
            AudienceOperand,
            ModelAggregationOperand,
        ]
    ]
):
    root: Union[
        bool,
        float,
        str,
        DateOperand,
        ModelPath,
        ModelOperand,
        AudienceOperand,
        ModelAggregationOperand,
    ] = Field(
        ...,
        description='Represents a value that can be used in expressions, including primitive values, paths, and arithmetic operations. Examples: 1. Primitive values:    true    42    "hello"\n\n2. Path reference:    { path: "user.age" }\n\n3. Arithmetic operation:    {      operator: "plus",      left: { path: "price" },      right: { path: "tax" }    }\n\n4. Nested arithmetic operation:    {      operator: "multiply",      left: { operator: "plus", left: { path: "base_price" }, right: { path: "shipping" } },      right: 1.1    }\n\n5. Date operand:    { date: { absolute: "2023-01-01T00:00:00Z" } }',
    )


class UnaryPathExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expression: PathExpression
    operator: UnaryOperator


class BinaryPathExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operand: Operand
    operator: BinaryOperator


class PathExpression(
    RootModel[Union[bool, float, str, UnaryPathExpression, BinaryPathExpression]]
):
    root: Union[bool, float, str, UnaryPathExpression, BinaryPathExpression] = Field(
        ...,
        description='Represents an expression that evaluates to a path or value. Examples: 1. Primitive values:    true    42    "hello"\n\n2. Unary expression (NOT):    {      operator: "not",      expression: { operator: "equals", operand: { path: "status" } }    }\n\n3. Binary expression (comparing a path to a value):    {      operator: "equals",      operand: { path: "user.age" }    }',
    )


AudienceDefinition.model_rebuild()
CountExpression1.model_rebuild()
CountExpression2.model_rebuild()
DateExpression2.model_rebuild()
UnaryExpression.model_rebuild()
BinaryExpression.model_rebuild()
LogicalExpression.model_rebuild()
LocationExpression2.model_rebuild()
ModelAggregationOperand.model_rebuild()
UnaryPathExpression.model_rebuild()
