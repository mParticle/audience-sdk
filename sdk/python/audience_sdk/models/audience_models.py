# generated by datamodel-codegen:
#   filename:  audience-definition-schema.json
#   timestamp: 2025-05-07T19:12:20+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, List, Literal, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel


class Model(RootModel[Any]):
    root: Any


class AbsoluteDate(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    absolute: str


class AggregationOperator(Enum):
    min = "min"
    max = "max"
    sum = "sum"
    avg = "avg"
    list = "list"
    count = "count"


class ArithmeticOperator(Enum):
    plus = "plus"
    minus = "minus"
    multiply = "multiply"
    divide = "divide"
    mod = "mod"


class BinaryOperator(Enum):
    equals = "equals"
    less_than = "less_than"
    less_than_equal = "less_than_equal"
    greater_than = "greater_than"
    greater_than_equal = "greater_than_equal"
    matches = "matches"
    contains = "contains"


class AbsoluteDateOperand(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    date: AbsoluteDate


class DateUnit(Enum):
    second = "second"
    minute = "minute"
    hour = "hour"
    day = "day"
    week = "week"
    month = "month"
    quarter = "quarter"
    year = "year"


class DistanceUnit(Enum):
    meters = "meters"
    miles = "miles"
    kilometers = "kilometers"


class Left(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operator: AggregationOperator
    path: str


class Right1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operator: AggregationOperator
    path: str


class Right2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    path: str


class Left1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    path: str


class ListOperator(Enum):
    contains = "contains"
    between = "between"
    match_any = "match_any"
    match_all = "match_all"
    in_ = "in"


class Distance(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    unit: DistanceUnit
    value: float


class Location(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    distance: Optional[Distance] = None
    latitude: float
    longitude: float


class LocationOperand(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    location: Location


class LocationOperator(Enum):
    within = "within"
    equals = "equals"


class LogicalOperator(Enum):
    and_ = "and"
    or_ = "or"


class ModelModel(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: float
    name: Optional[str] = None
    type: str


class Models(RootModel[Union[str, List[ModelModel]]]):
    root: Union[str, List[ModelModel]]


class PathOperand(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    path: str


class Boundary(Enum):
    start = "start"
    end = "end"
    middle = "middle"


class Relative(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    boundary: Optional[Boundary] = None
    offset: float
    unit: DateUnit


class RelativeDate(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    relative: Relative


class LocationSingleModelExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: LocationOperand
    operator: LocationOperator
    right: Right2


class LocationRightSingleModelExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: Left1
    operator: LocationOperator
    right: LocationOperand


class UnaryOperator(Enum):
    not_ = "not"
    exist = "exist"


class Version(RootModel[str]):
    root: str


class DateExpression1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operand: Union[AbsoluteDate, RelativeDate]
    operator: BinaryOperator


class RelativeDateOperand(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    date: RelativeDate


class DateOperand(RootModel[Union[AbsoluteDateOperand, RelativeDateOperand]]):
    root: Union[AbsoluteDateOperand, RelativeDateOperand] = Field(
        ...,
        description='Represents a date value that can be either absolute or relative. Examples: 1. Absolute date:    { date: { absolute: "2023-01-01T00:00:00Z" } }\n\n2. Relative date (30 days ago):    {       date: {         relative: {          offset: -30,          unit: "day"        }      }     }\n\n3. Relative date (start of current month):    {       date: {         relative: {          offset: 0,          unit: "month",          boundary: "start"        }      }     }',
    )


class LocationLeftExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: LocationOperand
    model: Optional[ModelModel] = None
    operator: LocationOperator
    right: Right2


class LocationRightExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: Left1
    model: Optional[ModelModel] = None
    operator: LocationOperator
    right: LocationOperand


class LocationExpression1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operand: Location
    operator: LocationOperator


class Audience(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operator: LogicalOperator
    queries: List[Union[LogicalAudienceQueries, AudienceQuery]]
    version: Version


class AudienceDefinition(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    audience: Audience = Field(..., title="Audience")


class AudienceQuery1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    query: Query


class EventAudienceQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    event: EventQuery


class UserAudienceQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    user: UserQuery


class AudienceQuery(RootModel[Union[AudienceQuery1, EventAudienceQuery, UserAudienceQuery]]):
    root: Union[AudienceQuery1, EventAudienceQuery, UserAudienceQuery] = Field(
        ...,
        description='Represents a query that can be either a general query, an event query, or a user query. Examples: 1. General query:    { query: { models: [{ type: "user", id: 1 }], expression: { ... } } }\n\n2. Event query:    { event: { models: [{ type: "event", id: 1 }], event_name: { path: "purchase" }, attributes: { ... } } }\n\n3. User query:    { user: { models: [{ type: "user", id: 1 }], attributes: { ... } } }',
    )


class CountExpression1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operand: Operand
    operator: BinaryOperator


class CountExpression2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expressions: List[CountExpression]
    operator: LogicalOperator


class CountExpression(RootModel[Union[float, CountExpression1, CountExpression2]]):
    root: Union[float, CountExpression1, CountExpression2] = Field(
        ...,
        description='Represents an expression that evaluates to a count or count-based condition. Examples:\n\n1. Simple count value:    5\n\n2. Count with binary operator:    {      operator: "greater_than",      operand: { path: "order_count" }    }\n\n3. Logical combination of counts:    {      operator: "and",      expressions: [        5,        {          operator: "greater_than",          operand: { path: "order_count" }        },        {          operator: "less_than",          operand: 10        }      ]    }',
    )


class DateExpression2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expressions: List[DateExpression]
    operator: LogicalOperator


class DateExpression(RootModel[Union[AbsoluteDate, RelativeDate, DateExpression1, DateExpression2]]):
    root: Union[AbsoluteDate, RelativeDate, DateExpression1, DateExpression2] = Field(
        ...,
        description='Represents an expression that evaluates to a date or date-based condition. Examples:\n\n1. Absolute date:    { absolute: "2023-01-01T00:00:00Z" }\n\n2. Relative date:    {      relative: {        offset: -30,        unit: "day"      }    }\n\n3. Date with binary operator:    {      operator: "greater_than",      operand: { absolute: "2023-01-01T00:00:00Z" }    }\n\n4. Logical combination of dates:    {      operator: "and",      expressions: [        { absolute: "2023-01-01T00:00:00Z" },        {          operator: "less_than",          operand: {            relative: {              offset: 0,              unit: "month",              boundary: "end"            }          }        }      ]    }',
    )


class EventQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    attributes: Optional[SingleModelExpression] = None
    count: Optional[CountExpression] = None
    date: Optional[DateExpression] = None
    event_name: Optional[PathExpression] = None
    event_type: Optional[PathExpression] = None
    expression: Optional[Expression] = None
    location: Optional[LocationExpression] = None
    models: Models


class JoinExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expression: Expression
    model: ModelModel


class UnaryExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expression: Expression
    model: Optional[ModelModel] = None
    operator: Literal["not"]


class ExistsExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model: Optional[ModelModel] = None
    operand: Operand
    operator: Literal["exists"]


class BinaryExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: Operand
    model: Optional[ModelModel] = None
    operator: BinaryOperator
    right: Operand


class Right(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expression: Expression
    model: str
    operator: AggregationOperator
    path: str


class ModelAggregationLeftExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expression: Expression
    left: Left
    model: ModelModel
    operator: BinaryOperator
    right: Union[Operand, Right]


class ModelAggregationOperand(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expression: Expression
    model: str
    operator: AggregationOperator
    path: str


class ModelAggregationRightExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expression: Expression
    left: Union[Operand, ModelAggregationOperand]
    model: ModelModel
    operator: BinaryOperator
    right: Right1


class LogicalExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expressions: List[Expression]
    model: Optional[ModelModel] = None
    operator: LogicalOperator


class Expression(
    RootModel[
        Union[
            JoinExpression,
            UnaryExpression,
            ExistsExpression,
            BinaryExpression,
            ModelAggregationLeftExpression,
            ModelAggregationRightExpression,
            LogicalExpression,
            LocationLeftExpression,
            LocationRightExpression,
        ]
    ]
):
    root: Union[
        JoinExpression,
        UnaryExpression,
        ExistsExpression,
        BinaryExpression,
        ModelAggregationLeftExpression,
        ModelAggregationRightExpression,
        LogicalExpression,
        LocationLeftExpression,
        LocationRightExpression,
    ] = Field(
        ...,
        description='Represents a complex expression that can evaluate to true, false, or noop. Examples:\n\n1. Join expression (combining expressions from different models):    {      model: { type: "user", id: 1 },      expression: {        operator: "equals",        left: { path: "age" },        right: 18      }    }\n\n2. Unary expression (operating on a single value):    {      operator: "not",      expression: {        operator: "equals",        left: { path: "status" },        right: "inactive"      }    }\n\n3. Binary expression (comparing two values):    {      operator: "greater_than",      left: { path: "price" },      right: 100    }\n\n4. Binary expression with aggregation:    {      operator: "greater_than",      left: {         model: { type: "order", id: 1 },         operator: "sum",         path: "amount",        expression: {          operator: "equals",          left: { path: "status" },          right: "completed"        }      },      right: 1000    }\n\n5. Binary expression with aggregation on both sides:    {      operator: "greater_than",      left: {         model: { type: "order", id: 1 },         operator: "sum",         path: "amount",        expression: {          operator: "equals",          left: { path: "status" },          right: "completed"        }      },      right: {         model: { type: "order", id: 1 },         operator: "sum",         path: "amount",        expression: {          operator: "equals",          left: { path: "status" },          right: "pending"        }      }    }\n\n6. Logical expression (AND/OR):    {      operator: "and",      expressions: [        {          operator: "equals",          left: { path: "country" },          right: "US"        },        {          operator: "greater_than",          left: { path: "age" },          right: 18        }      ]    }\n\n7. Location expression:    {      operator: "within",      left: {         location: {           latitude: 37.7749,           longitude: -122.4194,          distance: { value: 10, unit: "miles" }        }       },      right: { path: "user.location" }    }',
    )


class LocationExpression2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expressions: List[LocationExpression]
    operator: LogicalOperator


class LocationExpression(RootModel[Union[Location, LocationExpression1, LocationExpression2]]):
    root: Union[Location, LocationExpression1, LocationExpression2] = Field(
        ...,
        description='Represents an expression that evaluates to a location or location-based condition. Examples:\n\n1. Simple location:    {      latitude: 40.7128,      longitude: -74.0060,      distance: {        value: 5,        unit: "miles"      }    }\n\n2. Location with operator:    {      operator: "within",      operand: {        latitude: 40.7128,        longitude: -74.0060,        distance: {          value: 5,          unit: "miles"        }      }    }\n\n3. Logical combination of locations:    {      operator: "or",      expressions: [        {          latitude: 40.7128,          longitude: -74.0060,          distance: {            value: 5,            unit: "miles"          }        },        {          operator: "within",          operand: {            latitude: 34.0522,            longitude: -118.2437,            distance: {              value: 10,              unit: "miles"            }          }        }      ]    }',
    )


class LogicalAudienceQueries(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operator: LogicalOperator
    queries: List[Union[LogicalAudienceQueries, AudienceQuery]]


class ArithmeticOperand(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: Operand
    operator: ArithmeticOperator
    right: Operand


class Operand(RootModel[Union[bool, float, str, DateOperand, PathOperand, ArithmeticOperand]]):
    root: Union[bool, float, str, DateOperand, PathOperand, ArithmeticOperand] = Field(
        ...,
        description='Represents a value that can be used in expressions, including primitive values, paths, and arithmetic operations. Examples: 1. Primitive values:    - boolean: true    - number: 42    - string: "hello"\n\n2. Path reference:    { path: "user.age" }\n\n3. Arithmetic operation:    {      operator: "plus",      left: { path: "price" },      right: { path: "tax" }    }\n\n4. Nested arithmetic operation:    {      operator: "multiply",      left: {        operator: "plus",        left: { path: "base_price" },        right: { path: "shipping" }      },      right: 1.1  // 10% markup    }\n\n5. Date operand:    { date: { absolute: "2023-01-01T00:00:00Z" } }',
    )


class UnaryPathExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expression: PathExpression
    operator: UnaryOperator


class BinaryPathExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operand: Operand
    operator: BinaryOperator


class PathExpression(RootModel[Union[bool, float, str, UnaryPathExpression, BinaryPathExpression]]):
    root: Union[bool, float, str, UnaryPathExpression, BinaryPathExpression] = Field(
        ...,
        description='Represents an expression that evaluates to a path or value. Examples:\n\n1. Primitive values:    - boolean: true    - number: 42    - string: "hello"\n\n2. Unary expression (operating on a path):    {      operator: "not",      expression: {        operator: "equals",        left: { path: "status" },        right: "inactive"      }    }\n\n3. Binary expression (comparing a path to a value):    {      operator: "equals",      operand: { path: "user.age" }    }',
    )


class Query(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expression: Optional[Expression] = None
    models: Models


class NotSingleModelExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expression: SingleModelExpression
    operator: Literal["not"]


class ExistsSingleModelExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operand: Operand
    operator: Literal["exists"]


class BinarySingleModelExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    left: Operand
    operator: BinaryOperator
    right: Operand


class LogicalSingleModelExpression(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expressions: List[SingleModelExpression]
    operator: LogicalOperator


class SingleModelExpression(
    RootModel[
        Union[
            NotSingleModelExpression,
            ExistsSingleModelExpression,
            BinarySingleModelExpression,
            LogicalSingleModelExpression,
            LocationSingleModelExpression,
            LocationRightSingleModelExpression,
        ]
    ]
):
    root: Union[
        NotSingleModelExpression,
        ExistsSingleModelExpression,
        BinarySingleModelExpression,
        LogicalSingleModelExpression,
        LocationSingleModelExpression,
        LocationRightSingleModelExpression,
    ] = Field(
        ...,
        description='Represents an expression that operates within a single model context. Examples:\n\n1. Unary expression (operating on a single value):    {      operator: "not",      expression: {        operator: "equals",        left: { path: "status" },        right: "inactive"      }    }\n\n2. Binary expression (comparing two values):    {      operator: "greater_than",      left: { path: "price" },      right: 100    }\n\n3. Logical expression group (combining multiple expressions):    {      operator: "and",      expressions: [        {          operator: "equals",          left: { path: "country" },          right: "US"        },        {          operator: "greater_than",          left: { path: "age" },          right: 18        }      ]    }\n\n4. Location expression (comparing locations):    {      operator: "within",      left: {        location: {          latitude: 40.7128,          longitude: -74.0060,          distance: {            value: 5,            unit: "miles"          }        }      },      right: { path: "user.location" }    }',
    )


class UserQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    attributes: SingleModelExpression
    expression: Optional[Expression] = None
    models: Models


Audience.model_rebuild()
AudienceQuery1.model_rebuild()
EventAudienceQuery.model_rebuild()
UserAudienceQuery.model_rebuild()
CountExpression1.model_rebuild()
CountExpression2.model_rebuild()
DateExpression2.model_rebuild()
EventQuery.model_rebuild()
JoinExpression.model_rebuild()
UnaryExpression.model_rebuild()
ExistsExpression.model_rebuild()
BinaryExpression.model_rebuild()
Right.model_rebuild()
ModelAggregationLeftExpression.model_rebuild()
ModelAggregationOperand.model_rebuild()
ModelAggregationRightExpression.model_rebuild()
LogicalExpression.model_rebuild()
LocationExpression2.model_rebuild()
ArithmeticOperand.model_rebuild()
UnaryPathExpression.model_rebuild()
NotSingleModelExpression.model_rebuild()
LogicalSingleModelExpression.model_rebuild()
